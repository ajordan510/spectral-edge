"""
Batch Processor Worker Thread

This module provides a QThread-based worker for running batch processing
in the background without blocking the GUI.

Author: SpectralEdge Development Team
Date: 2026-02-02
"""

import logging
from typing import Dict, Any
from PyQt6.QtCore import QThread, pyqtSignal

from spectral_edge.batch.config import BatchConfig
from spectral_edge.batch.processor import BatchProcessor

logger = logging.getLogger(__name__)


class BatchWorker(QThread):
    """
    Worker thread for executing batch PSD processing.
    
    Runs the batch processor in a separate thread to prevent GUI freezing.
    Emits signals to update progress and report completion/errors.
    
    Signals:
    --------
    progress_updated : pyqtSignal(int, str)
        Emitted when progress changes. Args: (percent_complete, status_message)
    processing_complete : pyqtSignal(dict)
        Emitted when processing completes successfully. Args: (results_dict,)
    processing_failed : pyqtSignal(str)
        Emitted when processing fails. Args: (error_message,)
    log_message : pyqtSignal(str)
        Emitted for log messages during processing. Args: (message,)
    """
    
    progress_updated = pyqtSignal(int, str)
    processing_complete = pyqtSignal(dict)
    processing_failed = pyqtSignal(str)
    log_message = pyqtSignal(str)
    
    def __init__(self, config: BatchConfig):
        """
        Initialize the batch worker.
        
        Parameters:
        -----------
        config : BatchConfig
            Batch configuration object
        """
        super().__init__()
        self.config = config
        self.processor = None
        self._is_cancelled = False
    
    def run(self):
        """
        Execute the batch processing.
        
        This method runs in a separate thread and should not be called directly.
        Use start() instead.
        """
        try:
            self.log_message.emit("Initializing batch processor...")
            self.progress_updated.emit(0, "Initializing...")
            
            # Create batch processor
            self.processor = BatchProcessor(self.config)
            
            # Run batch processing
            self.log_message.emit("Starting batch processing...")
            self.progress_updated.emit(5, "Loading data...")
            
            # Run batch processing
            result = self.processor.process()
            
            if self._is_cancelled:
                self.log_message.emit("Batch processing cancelled by user")
                self.processing_failed.emit("Processing cancelled by user")
                return
            
            # Check for fatal errors
            if result.errors:
                error_summary = f"{len(result.errors)} error(s) occurred during processing"
                self.log_message.emit(error_summary)
                self.processing_failed.emit(error_summary)
                return
            
            self.progress_updated.emit(50, "Generating outputs...")
            self.log_message.emit("Processing complete, generating outputs...")
            
            # Generate outputs
            from spectral_edge.batch.excel_output import generate_excel_output
            from spectral_edge.batch.hdf5_output import write_psds_to_hdf5
            from spectral_edge.batch.powerpoint_output import generate_powerpoint_report
            
            output_config = self.config.output_config
            
            try:
                if output_config.excel_enabled:
                    self.log_message.emit("Generating Excel output...")
                    excel_path = generate_excel_output(result, output_config.output_directory)
                    self.log_message.emit(f"Excel saved: {excel_path}")
                
                if output_config.csv_enabled:
                    self.log_message.emit("Generating CSV outputs...")
                    # CSV is generated by excel_output module
                    self.log_message.emit("CSV files saved")
                
                if output_config.powerpoint_enabled:
                    self.log_message.emit("Generating PowerPoint report...")
                    ppt_path = generate_powerpoint_report(
                        result, 
                        output_config.output_directory,
                        self.config
                    )
                    self.log_message.emit(f"PowerPoint saved: {ppt_path}")
                
                if output_config.hdf5_writeback_enabled and self.config.source_type == "hdf5":
                    self.log_message.emit("Writing PSDs back to HDF5...")
                    write_psds_to_hdf5(result, self.config.source_files)
                    self.log_message.emit("HDF5 write-back complete")
                
            except Exception as e:
                error_msg = f"Error generating outputs: {str(e)}"
                self.log_message.emit(error_msg)
                self.processing_failed.emit(error_msg)
                return
            
            self.progress_updated.emit(100, "Complete!")
            self.log_message.emit("Batch processing completed successfully")
            
            # Convert result to dict for signal emission
            results_dict = {
                'channel_count': len(result.channel_results),
                'event_count': len(self.config.events) if not self.config.process_full_duration else 1,
                'warnings': len(result.warnings),
                'output_directory': output_config.output_directory
            }
            self.processing_complete.emit(results_dict)
            
        except Exception as e:
            error_msg = f"Batch processing failed: {str(e)}"
            logger.error(error_msg, exc_info=True)
            self.log_message.emit(error_msg)
            self.processing_failed.emit(error_msg)
    
    def cancel(self):
        """
        Request cancellation of the batch processing.
        
        Note: The cancellation is cooperative and may not take effect immediately.
        """
        self._is_cancelled = True
        self.log_message.emit("Cancellation requested...")
        
        if self.processor:
            self.processor.cancel_requested = True
